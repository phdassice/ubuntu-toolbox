#!/bin/bash

# Ubuntu Toolbox - 系統管理工具集
# 作者: phdassice
# 版本: 1.0.0

set -e

# 更新配置
UPDATE_CHECK_URL="https://api.github.com/repos/phdassice/ubuntu-toolbox/releases/latest"
SCRIPT_URL="https://raw.githubusercontent.com/phdassice/ubuntu-toolbox/main/toolbox"
LOCAL_VERSION="1.1.0"
UPDATE_CHECK_FILE="$HOME/.ubuntu-toolbox-update-check"

# 顏色定義
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 檢查網路連接
check_internet_connection() {
    if ping -c 1 8.8.8.8 &> /dev/null || ping -c 1 google.com &> /dev/null; then
        return 0
    else
        return 1
    fi
}

# 比較版本號
version_compare() {
    local version1=$1
    local version2=$2
    
    # 移除 'v' 前綴如果存在
    version1=${version1#v}
    version2=${version2#v}
    
    # 簡單的版本比較
    if [[ "$version1" == "$version2" ]]; then
        return 0  # 相等
    fi
    
    # 使用sort進行版本比較
    local sorted_versions=$(printf '%s\n%s\n' "$version1" "$version2" | sort -V)
    local lowest_version=$(echo "$sorted_versions" | head -n1)
    
    if [[ "$version1" == "$lowest_version" ]]; then
        return 1  # version1 < version2 (有更新)
    else
        return 2  # version1 > version2 (本地版本較新)
    fi
}

# 檢查更新
check_for_updates() {
    # 如果沒有網路連接，跳過更新檢查
    if ! check_internet_connection; then
        return 0
    fi
    
    # 檢查是否需要檢查更新 (每天檢查一次)
    local current_date=$(date +%Y-%m-%d)
    if [[ -f "$UPDATE_CHECK_FILE" ]]; then
        local last_check=$(cat "$UPDATE_CHECK_FILE" 2>/dev/null || echo "")
        if [[ "$last_check" == "$current_date" ]]; then
            return 0  # 今天已經檢查過了
        fi
    fi
    
    echo -e "${YELLOW}正在檢查更新...${NC}"
    
    # 獲取最新版本資訊
    local latest_info
    if command -v curl &> /dev/null; then
        latest_info=$(curl -s "$UPDATE_CHECK_URL" 2>/dev/null)
    elif command -v wget &> /dev/null; then
        latest_info=$(wget -qO- "$UPDATE_CHECK_URL" 2>/dev/null)
    else
        echo -e "${YELLOW}無法檢查更新: 缺少 curl 或 wget${NC}"
        return 0
    fi
    
    if [[ -z "$latest_info" ]]; then
        return 0  # 無法獲取更新資訊
    fi
    
    # 解析最新版本號 (簡單的JSON解析)
    local latest_version=$(echo "$latest_info" | grep -o '"tag_name":"[^"]*"' | cut -d'"' -f4)
    
    if [[ -z "$latest_version" ]]; then
        return 0  # 無法解析版本號
    fi
    
    # 記錄檢查日期
    echo "$current_date" > "$UPDATE_CHECK_FILE"
    
    # 比較版本
    version_compare "$LOCAL_VERSION" "$latest_version"
    local compare_result=$?
    
    if [[ $compare_result -eq 1 ]]; then
        echo
        echo -e "${GREEN}🎉 發現新版本！${NC}"
        echo -e "${CYAN}當前版本: $LOCAL_VERSION${NC}"
        echo -e "${CYAN}最新版本: $latest_version${NC}"
        echo
        
        # 獲取更新說明
        local release_notes=$(echo "$latest_info" | grep -o '"body":"[^"]*"' | cut -d'"' -f4 | sed 's/\\n/\n/g' | head -5)
        if [[ ! -z "$release_notes" ]]; then
            echo -e "${BLUE}更新說明:${NC}"
            echo "$release_notes"
            echo
        fi
        
        read -p "是否要下載並安裝最新版本? [y/N]: " install_update
        if [[ $install_update =~ ^[Yy]$ ]]; then
            install_update_function
        fi
    elif [[ $compare_result -eq 2 ]]; then
        echo -e "${GREEN}您使用的是開發版本 ($LOCAL_VERSION)${NC}"
    fi
}

# 安裝更新
install_update_function() {
    echo -e "${YELLOW}正在下載最新版本...${NC}"
    
    # 備份當前版本
    local backup_file="./toolbox.backup.$(date +%Y%m%d_%H%M%S)"
    cp "$0" "$backup_file"
    echo -e "${GREEN}已備份當前版本到: $backup_file${NC}"
    
    # 下載最新版本
    local temp_file="/tmp/toolbox.new"
    if command -v curl &> /dev/null; then
        if curl -sL "$SCRIPT_URL" -o "$temp_file"; then
            echo -e "${GREEN}下載完成${NC}"
        else
            echo -e "${RED}下載失敗${NC}"
            return 1
        fi
    elif command -v wget &> /dev/null; then
        if wget -q "$SCRIPT_URL" -O "$temp_file"; then
            echo -e "${GREEN}下載完成${NC}"
        else
            echo -e "${RED}下載失敗${NC}"
            return 1
        fi
    else
        echo -e "${RED}錯誤: 需要 curl 或 wget 來下載更新${NC}"
        return 1
    fi
    
    # 驗證下載的文件
    if [[ ! -f "$temp_file" ]] || [[ ! -s "$temp_file" ]]; then
        echo -e "${RED}下載的文件無效${NC}"
        return 1
    fi
    
    # 檢查文件是否為有效的bash腳本
    if ! head -1 "$temp_file" | grep -q "#!/bin/bash"; then
        echo -e "${RED}下載的文件不是有效的bash腳本${NC}"
        return 1
    fi
    
    echo -e "${YELLOW}正在安裝更新...${NC}"
    
    # 替換當前腳本
    if cp "$temp_file" "$0"; then
        chmod +x "$0"
        rm -f "$temp_file"
        echo -e "${GREEN}✓ 更新安裝成功！${NC}"
        echo -e "${YELLOW}請重新運行工具箱以使用新版本${NC}"
        echo
        read -p "是否立即重啟工具箱? [y/N]: " restart_toolbox
        if [[ $restart_toolbox =~ ^[Yy]$ ]]; then
            echo -e "${GREEN}正在重啟工具箱...${NC}"
            exec "$0"
        else
            exit 0
        fi
    else
        echo -e "${RED}更新安裝失敗${NC}"
        echo -e "${YELLOW}您可以手動從備份文件恢復: $backup_file${NC}"
        return 1
    fi
}

# 手動檢查更新
manual_update_check() {
    show_header
    echo -e "${BLUE}=== 手動檢查更新 ===${NC}"
    echo
    
    if ! check_internet_connection; then
        echo -e "${RED}錯誤: 無法連接到網際網路${NC}"
        echo -e "${YELLOW}請檢查您的網路連接後重試${NC}"
        echo
        read -p "按任意鍵返回主菜單..." -n1 -s
        return
    fi
    
    # 強制檢查更新
    rm -f "$UPDATE_CHECK_FILE"
    check_for_updates
    
    echo
    read -p "按任意鍵返回主菜單..." -n1 -s
}

# 顯示標題
show_header() {
    clear
    echo -e "${CYAN}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║                    ${YELLOW}Ubuntu 工具箱${CYAN}                          ║${NC}"
    echo -e "${CYAN}║                    ${GREEN}v1.0.0${CYAN}                                ║${NC}"
    echo -e "${CYAN}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo
}

# 顯示主菜單
show_menu() {
    echo -e "${BLUE}請選擇要執行的功能：${NC}"
    echo
    echo -e "${GREEN}1.${NC} Docker Dangling Images 清理"
    echo -e "${GREEN}2.${NC} 系統狀態查詢"
    echo -e "${GREEN}3.${NC} 網路速度測試"
    echo -e "${GREEN}4.${NC} 系統資訊總覽"
    echo -e "${GREEN}5.${NC} 網路介面管理"
    echo -e "${GREEN}6.${NC} 檢查更新"
    echo -e "${RED}0.${NC} 退出工具箱"
    echo
    echo -n -e "${YELLOW}請輸入選項 [0-6]: ${NC}"
}

# 檢查 Docker 是否安裝
check_docker() {
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}錯誤: Docker 未安裝或不在 PATH 中${NC}"
        echo -e "${YELLOW}請先安裝 Docker 再使用此功能${NC}"
        return 1
    fi
    
    if ! docker info &> /dev/null; then
        echo -e "${RED}錯誤: Docker daemon 未運行或權限不足${NC}"
        echo -e "${YELLOW}請確保 Docker 服務正在運行，並且您有執行 Docker 的權限${NC}"
        return 1
    fi
    return 0
}

# Docker Dangling Images 清理
cleanup_docker_images() {
    show_header
    echo -e "${BLUE}=== Docker Dangling Images 清理 ===${NC}"
    echo
    
    if ! check_docker; then
        echo
        read -p "按任意鍵返回主菜單..." -n1 -s
        return
    fi
    
    echo -e "${YELLOW}正在檢查 dangling images...${NC}"
    
    # 獲取 dangling images
    dangling_images=$(docker images -f "dangling=true" -q)
    
    if [ -z "$dangling_images" ]; then
        echo -e "${GREEN}✓ 沒有找到 dangling images，系統已經很乾淨了！${NC}"
    else
        echo -e "${YELLOW}找到以下 dangling images:${NC}"
        docker images -f "dangling=true"
        echo
        
        read -p "確定要刪除這些 dangling images 嗎? [y/N]: " confirm
        if [[ $confirm =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}正在清理 dangling images...${NC}"
            
            # 記錄清理前的空間
            space_before=$(df -h / | awk 'NR==2 {print $4}')
            
            # 清理 dangling images
            docker rmi $(docker images -f "dangling=true" -q) 2>/dev/null || echo -e "${YELLOW}某些映像可能正在使用中${NC}"
            
            # 記錄清理後的空間
            space_after=$(df -h / | awk 'NR==2 {print $4}')
            
            echo -e "${GREEN}✓ Dangling images 清理完成！${NC}"
            echo -e "${CYAN}清理前可用空間: $space_before${NC}"
            echo -e "${CYAN}清理後可用空間: $space_after${NC}"
        else
            echo -e "${YELLOW}取消清理操作${NC}"
        fi
    fi
    
    echo
    echo -e "${BLUE}是否要執行完整的 Docker 系統清理？${NC}"
    read -p "這將清理所有未使用的容器、網路、映像和構建緩存 [y/N]: " full_cleanup
    if [[ $full_cleanup =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}正在執行完整系統清理...${NC}"
        docker system prune -a --volumes -f
        echo -e "${GREEN}✓ Docker 系統清理完成！${NC}"
    fi
    
    echo
    read -p "按任意鍵返回主菜單..." -n1 -s
}

# 系統狀態查詢
system_status() {
    show_header
    echo -e "${BLUE}=== 系統狀態查詢 ===${NC}"
    echo
    
    # 系統基本信息
    echo -e "${GREEN}📋 系統資訊:${NC}"
    echo "────────────────────────────────────────"
    echo "作業系統: $(lsb_release -d | cut -f2)"
    echo "核心版本: $(uname -r)"
    echo "主機名稱: $(hostname)"
    echo "系統運行時間: $(uptime -p)"
    echo
    
    # CPU 資訊
    echo -e "${GREEN}🖥️  CPU 資訊:${NC}"
    echo "────────────────────────────────────────"
    echo "CPU 型號: $(lscpu | grep "Model name" | cut -d: -f2 | xargs)"
    echo "CPU 核心數: $(nproc)"
    echo "CPU 使用率:"
    top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print "  使用中: " 100-$1 "% | 閒置: " $1 "%"}'
    echo
    
    # 記憶體資訊
    echo -e "${GREEN}🧠 記憶體資訊:${NC}"
    echo "────────────────────────────────────────"
    free -h | awk '
    NR==1{print "類型\t\t總計\t\t已使用\t\t可用\t\t使用率"}
    NR==2{
        total=$2; used=$3; available=$7;
        if($2~/G/) {total_gb=total} else {total_gb=total/1024}
        if($3~/G/) {used_gb=used} else {used_gb=used/1024}
        if($7~/G/) {avail_gb=available} else {avail_gb=available/1024}
        printf "記憶體\t\t%s\t\t%s\t\t%s\t\t%.1f%%\n", total, used, available, (used_gb/total_gb)*100
    }'
    echo
    
    # 磁碟使用情況
    echo -e "${GREEN}💾 磁碟使用情況:${NC}"
    echo "────────────────────────────────────────"
    df -h | grep -E '^/dev/' | awk '{
        printf "%-20s %8s %8s %8s %8s %s\n", $1, $2, $3, $4, $5, $6
    }' | head -1
    echo "────────────────────────────────────────────────────────────────────────"
    df -h | grep -E '^/dev/' | awk '{
        printf "%-20s %8s %8s %8s %8s %s\n", $1, $2, $3, $4, $5, $6
    }' | tail -n +2
    echo
    
    # 系統負載
    echo -e "${GREEN}⚡ 系統負載:${NC}"
    echo "────────────────────────────────────────"
    uptime | awk -F'load average:' '{print "平均負載:" $2}'
    echo
    
    # 網路介面
    echo -e "${GREEN}🌐 網路介面:${NC}"
    echo "────────────────────────────────────────"
    ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | while read ip; do
        interface=$(ip route get $ip | grep -oP '(?<=dev\s)\w+' | head -1)
        echo "介面: $interface | IP: $ip"
    done
    echo
    
    # 活躍的網路連接
    echo -e "${GREEN}🔗 活躍連接 (前10個):${NC}"
    echo "────────────────────────────────────────"
    netstat -tuln 2>/dev/null | head -11 || ss -tuln | head -11
    echo
    
    read -p "按任意鍵返回主菜單..." -n1 -s
}

# 檢查 speedtest-cli 是否安裝
check_speedtest() {
    if ! command -v speedtest-cli &> /dev/null; then
        echo -e "${YELLOW}speedtest-cli 未安裝，正在安裝...${NC}"
        if command -v apt &> /dev/null; then
            sudo apt update && sudo apt install -y speedtest-cli
        elif command -v yum &> /dev/null; then
            sudo yum install -y speedtest-cli
        elif command -v pip3 &> /dev/null; then
            pip3 install speedtest-cli
        else
            echo -e "${RED}無法自動安裝 speedtest-cli，請手動安裝${NC}"
            return 1
        fi
    fi
    return 0
}

# 網路速度測試
network_speed_test() {
    show_header
    echo -e "${BLUE}=== 網路速度測試 ===${NC}"
    echo
    
    if ! check_speedtest; then
        echo
        read -p "按任意鍵返回主菜單..." -n1 -s
        return
    fi
    
    echo -e "${YELLOW}正在測試網路速度，請稍候...${NC}"
    echo -e "${CYAN}這可能需要幾分鐘時間${NC}"
    echo
    
    # 顯示測試進度
    echo -e "${YELLOW}正在選擇最佳測試伺服器...${NC}"
    
    # 執行速度測試
    speedtest_result=$(speedtest-cli --simple 2>/dev/null)
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ 網路速度測試完成！${NC}"
        echo
        echo -e "${BLUE}📊 測試結果:${NC}"
        echo "════════════════════════════════════════"
        
        # 解析結果
        ping=$(echo "$speedtest_result" | grep "Ping:" | awk '{print $2 " " $3}')
        download=$(echo "$speedtest_result" | grep "Download:" | awk '{print $2 " " $3}')
        upload=$(echo "$speedtest_result" | grep "Upload:" | awk '{print $2 " " $3}')
        
        echo -e "${CYAN}延遲 (Ping):     ${YELLOW}$ping${NC}"
        echo -e "${CYAN}下載速度:        ${GREEN}$download${NC}"
        echo -e "${CYAN}上傳速度:        ${GREEN}$upload${NC}"
        echo
        
        # 速度評估
        download_mbps=$(echo "$download" | awk '{print $1}')
        if (( $(echo "$download_mbps > 100" | bc -l) )); then
            echo -e "${GREEN}🚀 網路速度很棒！${NC}"
        elif (( $(echo "$download_mbps > 50" | bc -l) )); then
            echo -e "${YELLOW}⚡ 網路速度良好${NC}"
        elif (( $(echo "$download_mbps > 25" | bc -l) )); then
            echo -e "${YELLOW}📶 網路速度普通${NC}"
        else
            echo -e "${RED}🐌 網路速度較慢${NC}"
        fi
        
        echo
        echo -e "${BLUE}是否要保存測試結果到文件？${NC}"
        read -p "[y/N]: " save_result
        if [[ $save_result =~ ^[Yy]$ ]]; then
            timestamp=$(date "+%Y-%m-%d_%H-%M-%S")
            result_file="speedtest_result_$timestamp.txt"
            {
                echo "網路速度測試結果"
                echo "測試時間: $(date)"
                echo "══════════════════════════════════════"
                echo "$speedtest_result"
            } > "$result_file"
            echo -e "${GREEN}✓ 結果已保存到: $result_file${NC}"
        fi
    else
        echo -e "${RED}✗ 網路速度測試失敗${NC}"
        echo -e "${YELLOW}請檢查網路連接後重試${NC}"
    fi
    
    echo
    read -p "按任意鍵返回主菜單..." -n1 -s
}

# 系統資訊總覽
system_overview() {
    show_header
    echo -e "${BLUE}=== 系統資訊總覽 ===${NC}"
    echo
    
    # 快速健康檢查
    echo -e "${GREEN}🏥 系統健康檢查:${NC}"
    echo "────────────────────────────────────────"
    
    # 檢查磁碟空間
    disk_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ "$disk_usage" -gt 90 ]; then
        echo -e "${RED}⚠️  磁碟空間: ${disk_usage}% (警告: 空間不足)${NC}"
    elif [ "$disk_usage" -gt 80 ]; then
        echo -e "${YELLOW}⚠️  磁碟空間: ${disk_usage}% (注意: 空間偏低)${NC}"
    else
        echo -e "${GREEN}✓ 磁碟空間: ${disk_usage}% (正常)${NC}"
    fi
    
    # 檢查記憶體使用
    mem_usage=$(free | awk 'NR==2{printf "%.0f", $3*100/$2}')
    if [ "$mem_usage" -gt 90 ]; then
        echo -e "${RED}⚠️  記憶體使用: ${mem_usage}% (警告: 使用率過高)${NC}"
    elif [ "$mem_usage" -gt 80 ]; then
        echo -e "${YELLOW}⚠️  記憶體使用: ${mem_usage}% (注意: 使用率偏高)${NC}"
    else
        echo -e "${GREEN}✓ 記憶體使用: ${mem_usage}% (正常)${NC}"
    fi
    
    # 檢查系統負載
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
    cpu_cores=$(nproc)
    load_percentage=$(echo "scale=0; $load_avg * 100 / $cpu_cores" | bc)
    
    if [ "$load_percentage" -gt 100 ]; then
        echo -e "${RED}⚠️  系統負載: ${load_avg} (警告: 負載過高)${NC}"
    elif [ "$load_percentage" -gt 80 ]; then
        echo -e "${YELLOW}⚠️  系統負載: ${load_avg} (注意: 負載偏高)${NC}"
    else
        echo -e "${GREEN}✓ 系統負載: ${load_avg} (正常)${NC}"
    fi
    
    echo
    
    # 快速統計
    echo -e "${GREEN}📈 快速統計:${NC}"
    echo "────────────────────────────────────────"
    echo "系統啟動時間: $(uptime -s)"
    echo "運行時間: $(uptime -p)"
    echo "當前用戶: $(whoami)"
    echo "登入用戶數: $(who | wc -l)"
    echo "運行進程數: $(ps aux | wc -l)"
    echo
    
    # 前5個消耗CPU的進程
    echo -e "${GREEN}🔝 CPU 使用率最高的進程 (前5個):${NC}"
    echo "────────────────────────────────────────"
    ps aux --sort=-%cpu | awk 'NR==1{print "USER\t\tPID\t%CPU\t%MEM\tCOMMAND"} NR>=2&&NR<=6{printf "%-12s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $11}'
    echo
    
    # 前5個消耗記憶體的進程
    echo -e "${GREEN}🧠 記憶體使用量最高的進程 (前5個):${NC}"
    echo "────────────────────────────────────────"
    ps aux --sort=-%mem | awk 'NR==1{print "USER\t\tPID\t%CPU\t%MEM\tCOMMAND"} NR>=2&&NR<=6{printf "%-12s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $11}'
    echo
    
    read -p "按任意鍵返回主菜單..." -n1 -s
}

# 檢查網路管理權限
check_network_permissions() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${YELLOW}網路介面管理需要 root 權限${NC}"
        echo -e "${YELLOW}請使用 sudo 執行此腳本以使用網路功能${NC}"
        return 1
    fi
    return 0
}

# 顯示當前網路介面
show_current_interfaces() {
    echo -e "${GREEN}📡 當前網路介面:${NC}"
    echo "════════════════════════════════════════════════════════════"
    ip link show | grep -E '^[0-9]+:' | while read line; do
        interface=$(echo $line | awk '{print $2}' | sed 's/://')
        state=$(echo $line | grep -o 'state [A-Z]*' | awk '{print $2}')
        
        case $state in
            "UP")
                state_color="${GREEN}"
                ;;
            "DOWN")
                state_color="${RED}"
                ;;
            *)
                state_color="${YELLOW}"
                ;;
        esac
        
        echo -e "介面: ${CYAN}$interface${NC} | 狀態: ${state_color}$state${NC}"
        
        # 顯示IP地址
        ip_addr=$(ip addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -1)
        if [ ! -z "$ip_addr" ]; then
            echo -e "  └─ IP: ${BLUE}$ip_addr${NC}"
        fi
    done
    echo
}

# 網路介面管理子菜單
show_network_menu() {
    echo -e "${BLUE}網路介面管理選項：${NC}"
    echo
    echo -e "${GREEN}1.${NC} 查看當前網路介面"
    echo -e "${GREEN}2.${NC} 創建虛擬網路介面 (dummy)"
    echo -e "${GREEN}3.${NC} 創建網路橋接 (bridge)"
    echo -e "${GREEN}4.${NC} 創建 VLAN 介面"
    echo -e "${GREEN}5.${NC} 配置介面 IP 地址"
    echo -e "${GREEN}6.${NC} 啟用/停用網路介面"
    echo -e "${GREEN}7.${NC} 刪除虛擬網路介面"
    echo -e "${GREEN}8.${NC} 網路介面流量監控"
    echo -e "${RED}0.${NC} 返回主菜單"
    echo
    echo -n -e "${YELLOW}請選擇操作 [0-8]: ${NC}"
}

# 創建虛擬網路介面 (dummy)
create_dummy_interface() {
    echo -e "${BLUE}=== 創建虛擬網路介面 (dummy) ===${NC}"
    echo
    
    read -p "請輸入虛擬介面名稱 (例如: dummy0): " interface_name
    
    if [ -z "$interface_name" ]; then
        echo -e "${RED}錯誤: 介面名稱不能為空${NC}"
        return
    fi
    
    # 檢查介面是否已存在
    if ip link show $interface_name &>/dev/null; then
        echo -e "${RED}錯誤: 介面 $interface_name 已存在${NC}"
        return
    fi
    
    echo -e "${YELLOW}正在創建虛擬介面 $interface_name...${NC}"
    
    # 創建 dummy 介面
    if ip link add $interface_name type dummy; then
        echo -e "${GREEN}✓ 虛擬介面 $interface_name 創建成功${NC}"
        
        # 詢問是否立即啟用
        read -p "是否立即啟用此介面? [y/N]: " enable_interface
        if [[ $enable_interface =~ ^[Yy]$ ]]; then
            ip link set $interface_name up
            echo -e "${GREEN}✓ 介面 $interface_name 已啟用${NC}"
            
            # 詢問是否配置IP
            read -p "是否要配置IP地址? [y/N]: " config_ip
            if [[ $config_ip =~ ^[Yy]$ ]]; then
                configure_interface_ip $interface_name
            fi
        fi
    else
        echo -e "${RED}✗ 創建虛擬介面失敗${NC}"
    fi
}

# 創建網路橋接
create_bridge_interface() {
    echo -e "${BLUE}=== 創建網路橋接 (bridge) ===${NC}"
    echo
    
    read -p "請輸入橋接名稱 (例如: br0): " bridge_name
    
    if [ -z "$bridge_name" ]; then
        echo -e "${RED}錯誤: 橋接名稱不能為空${NC}"
        return
    fi
    
    # 檢查介面是否已存在
    if ip link show $bridge_name &>/dev/null; then
        echo -e "${RED}錯誤: 介面 $bridge_name 已存在${NC}"
        return
    fi
    
    echo -e "${YELLOW}正在創建橋接 $bridge_name...${NC}"
    
    # 創建 bridge 介面
    if ip link add $bridge_name type bridge; then
        echo -e "${GREEN}✓ 橋接 $bridge_name 創建成功${NC}"
        
        # 啟用橋接
        ip link set $bridge_name up
        echo -e "${GREEN}✓ 橋接 $bridge_name 已啟用${NC}"
        
        # 詢問是否添加現有介面到橋接
        echo
        echo -e "${BLUE}可用的物理網路介面:${NC}"
        ip link show | grep -E '^[0-9]+:.*eth|^[0-9]+:.*ens' | awk '{print $2}' | sed 's/://' | nl
        echo
        read -p "是否要將現有介面添加到橋接? [y/N]: " add_interface
        if [[ $add_interface =~ ^[Yy]$ ]]; then
            read -p "請輸入要添加的介面名稱: " physical_interface
            if [ ! -z "$physical_interface" ] && ip link show $physical_interface &>/dev/null; then
                ip link set $physical_interface master $bridge_name
                echo -e "${GREEN}✓ 介面 $physical_interface 已添加到橋接 $bridge_name${NC}"
            else
                echo -e "${RED}錯誤: 介面 $physical_interface 不存在${NC}"
            fi
        fi
        
        # 詢問是否配置IP
        read -p "是否要為橋接配置IP地址? [y/N]: " config_ip
        if [[ $config_ip =~ ^[Yy]$ ]]; then
            configure_interface_ip $bridge_name
        fi
    else
        echo -e "${RED}✗ 創建橋接失敗${NC}"
    fi
}

# 創建 VLAN 介面
create_vlan_interface() {
    echo -e "${BLUE}=== 創建 VLAN 介面 ===${NC}"
    echo
    
    # 顯示可用的物理介面
    echo -e "${GREEN}可用的物理網路介面:${NC}"
    ip link show | grep -E '^[0-9]+:.*eth|^[0-9]+:.*ens' | awk '{print $2}' | sed 's/://'
    echo
    
    read -p "請輸入父介面名稱 (例如: eth0): " parent_interface
    read -p "請輸入 VLAN ID (例如: 100): " vlan_id
    
    if [ -z "$parent_interface" ] || [ -z "$vlan_id" ]; then
        echo -e "${RED}錯誤: 父介面和 VLAN ID 不能為空${NC}"
        return
    fi
    
    # 檢查父介面是否存在
    if ! ip link show $parent_interface &>/dev/null; then
        echo -e "${RED}錯誤: 父介面 $parent_interface 不存在${NC}"
        return
    fi
    
    # 檢查 VLAN ID 是否為數字
    if ! [[ "$vlan_id" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}錯誤: VLAN ID 必須是數字${NC}"
        return
    fi
    
    vlan_interface="${parent_interface}.${vlan_id}"
    
    echo -e "${YELLOW}正在創建 VLAN 介面 $vlan_interface...${NC}"
    
    # 創建 VLAN 介面
    if ip link add link $parent_interface name $vlan_interface type vlan id $vlan_id; then
        echo -e "${GREEN}✓ VLAN 介面 $vlan_interface 創建成功${NC}"
        
        # 啟用 VLAN 介面
        ip link set $vlan_interface up
        echo -e "${GREEN}✓ VLAN 介面 $vlan_interface 已啟用${NC}"
        
        # 詢問是否配置IP
        read -p "是否要配置IP地址? [y/N]: " config_ip
        if [[ $config_ip =~ ^[Yy]$ ]]; then
            configure_interface_ip $vlan_interface
        fi
    else
        echo -e "${RED}✗ 創建 VLAN 介面失敗${NC}"
    fi
}

# 配置介面 IP 地址
configure_interface_ip() {
    local interface=$1
    
    if [ -z "$interface" ]; then
        echo -e "${BLUE}=== 配置介面 IP 地址 ===${NC}"
        echo
        echo -e "${GREEN}可用的網路介面:${NC}"
        ip link show | awk -F': ' '/^[0-9]+:/ {print $2}' | nl
        echo
        read -p "請輸入要配置的介面名稱: " interface
    fi
    
    if [ -z "$interface" ]; then
        echo -e "${RED}錯誤: 介面名稱不能為空${NC}"
        return
    fi
    
    # 檢查介面是否存在
    if ! ip link show $interface &>/dev/null; then
        echo -e "${RED}錯誤: 介面 $interface 不存在${NC}"
        return
    fi
    
    # 顯示當前IP配置
    echo -e "${GREEN}當前 IP 配置:${NC}"
    ip addr show $interface | grep -E 'inet ' | awk '{print "  " $2}' || echo "  無IP地址"
    echo
    
    read -p "請輸入IP地址和子網掩碼 (例如: 192.168.1.100/24): " ip_cidr
    
    if [ -z "$ip_cidr" ]; then
        echo -e "${RED}錯誤: IP地址不能為空${NC}"
        return
    fi
    
    # 驗證IP地址格式
    if ! echo $ip_cidr | grep -E '^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$' &>/dev/null; then
        echo -e "${RED}錯誤: IP地址格式不正確${NC}"
        return
    fi
    
    echo -e "${YELLOW}正在配置 IP 地址...${NC}"
    
    # 配置IP地址
    if ip addr add $ip_cidr dev $interface; then
        echo -e "${GREEN}✓ IP 地址配置成功${NC}"
        
        # 詢問是否配置網關
        read -p "是否要配置預設網關? [y/N]: " config_gateway
        if [[ $config_gateway =~ ^[Yy]$ ]]; then
            read -p "請輸入網關地址: " gateway
            if [ ! -z "$gateway" ]; then
                ip route add default via $gateway dev $interface
                echo -e "${GREEN}✓ 網關配置成功${NC}"
            fi
        fi
        
        # 顯示最終配置
        echo
        echo -e "${GREEN}最終網路配置:${NC}"
        ip addr show $interface | grep -E 'inet '
    else
        echo -e "${RED}✗ IP 地址配置失敗${NC}"
    fi
}

# 啟用/停用網路介面
toggle_interface() {
    echo -e "${BLUE}=== 啟用/停用網路介面 ===${NC}"
    echo
    
    show_current_interfaces
    
    read -p "請輸入要操作的介面名稱: " interface
    
    if [ -z "$interface" ]; then
        echo -e "${RED}錯誤: 介面名稱不能為空${NC}"
        return
    fi
    
    # 檢查介面是否存在
    if ! ip link show $interface &>/dev/null; then
        echo -e "${RED}錯誤: 介面 $interface 不存在${NC}"
        return
    fi
    
    # 獲取當前狀態
    current_state=$(ip link show $interface | grep -o 'state [A-Z]*' | awk '{print $2}')
    
    echo -e "${GREEN}當前狀態: $current_state${NC}"
    echo
    echo -e "${BLUE}選擇操作:${NC}"
    echo -e "${GREEN}1.${NC} 啟用介面"
    echo -e "${GREEN}2.${NC} 停用介面"
    echo
    read -p "請選擇 [1-2]: " action
    
    case $action in
        1)
            echo -e "${YELLOW}正在啟用介面 $interface...${NC}"
            if ip link set $interface up; then
                echo -e "${GREEN}✓ 介面 $interface 已啟用${NC}"
            else
                echo -e "${RED}✗ 啟用介面失敗${NC}"
            fi
            ;;
        2)
            echo -e "${YELLOW}正在停用介面 $interface...${NC}"
            if ip link set $interface down; then
                echo -e "${GREEN}✓ 介面 $interface 已停用${NC}"
            else
                echo -e "${RED}✗ 停用介面失敗${NC}"
            fi
            ;;
        *)
            echo -e "${RED}無效的選項${NC}"
            ;;
    esac
}

# 刪除虛擬網路介面
delete_virtual_interface() {
    echo -e "${BLUE}=== 刪除虛擬網路介面 ===${NC}"
    echo
    
    echo -e "${GREEN}虛擬網路介面 (可安全刪除):${NC}"
    echo "════════════════════════════════════════"
    
    # 顯示虛擬介面
    virtual_interfaces=$(ip link show | grep -E 'dummy|bridge|vlan' | awk -F': ' '{print $2}' | awk '{print $1}')
    
    if [ -z "$virtual_interfaces" ]; then
        echo -e "${YELLOW}沒有找到虛擬網路介面${NC}"
        return
    fi
    
    echo "$virtual_interfaces" | nl
    echo
    
    read -p "請輸入要刪除的介面名稱: " interface
    
    if [ -z "$interface" ]; then
        echo -e "${RED}錯誤: 介面名稱不能為空${NC}"
        return
    fi
    
    # 檢查介面是否存在
    if ! ip link show $interface &>/dev/null; then
        echo -e "${RED}錯誤: 介面 $interface 不存在${NC}"
        return
    fi
    
    # 確認刪除
    echo -e "${RED}警告: 即將刪除介面 $interface${NC}"
    read -p "確定要刪除嗎? [y/N]: " confirm
    
    if [[ $confirm =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}正在刪除介面 $interface...${NC}"
        
        # 先停用介面
        ip link set $interface down 2>/dev/null
        
        # 刪除介面
        if ip link delete $interface; then
            echo -e "${GREEN}✓ 介面 $interface 已成功刪除${NC}"
        else
            echo -e "${RED}✗ 刪除介面失敗${NC}"
        fi
    else
        echo -e "${YELLOW}取消刪除操作${NC}"
    fi
}

# 網路介面流量監控
monitor_interface_traffic() {
    echo -e "${BLUE}=== 網路介面流量監控 ===${NC}"
    echo
    
    echo -e "${GREEN}可用的網路介面:${NC}"
    ip link show | awk -F': ' '/^[0-9]+:/ {print $2}' | nl
    echo
    
    read -p "請輸入要監控的介面名稱 (按 Enter 監控所有介面): " interface
    
    if [ -z "$interface" ]; then
        echo -e "${YELLOW}監控所有網路介面流量 (按 Ctrl+C 停止)...${NC}"
        echo
        
        # 監控所有介面
        while true; do
            clear
            echo -e "${BLUE}=== 網路流量監控 (實時) ===${NC}"
            echo "更新時間: $(date)"
            echo "════════════════════════════════════════════════════════════"
            
            # 顯示網路統計
            cat /proc/net/dev | awk '
            NR>2 {
                interface = $1
                gsub(/:/, "", interface)
                rx_bytes = $2
                tx_bytes = $10
                printf "%-12s RX: %10.2f MB  TX: %10.2f MB\n", 
                       interface, rx_bytes/1024/1024, tx_bytes/1024/1024
            }'
            
            sleep 2
        done
    else
        # 檢查指定介面是否存在
        if ! ip link show $interface &>/dev/null; then
            echo -e "${RED}錯誤: 介面 $interface 不存在${NC}"
            return
        fi
        
        echo -e "${YELLOW}監控介面 $interface 流量 (按 Ctrl+C 停止)...${NC}"
        echo
        
        # 監控指定介面
        while true; do
            clear
            echo -e "${BLUE}=== 介面 $interface 流量監控 ===${NC}"
            echo "更新時間: $(date)"
            echo "════════════════════════════════════════════════════════════"
            
            # 獲取流量統計
            stats=$(cat /proc/net/dev | grep "$interface:" | awk '{print $2 " " $10}')
            if [ ! -z "$stats" ]; then
                rx_bytes=$(echo $stats | awk '{print $1}')
                tx_bytes=$(echo $stats | awk '{print $2}')
                
                echo -e "${GREEN}接收 (RX):${NC}"
                echo "  位元組: $(numfmt --to=iec-i --suffix=B $rx_bytes)"
                echo
                echo -e "${GREEN}傳送 (TX):${NC}"
                echo "  位元組: $(numfmt --to=iec-i --suffix=B $tx_bytes)"
                echo
                
                # 顯示介面詳細資訊
                echo -e "${GREEN}介面資訊:${NC}"
                ip addr show $interface | grep -E 'inet |ether'
            else
                echo -e "${RED}無法獲取介面 $interface 的統計資訊${NC}"
            fi
            
            sleep 2
        done
    fi
}

# 網路介面管理主函數
network_interface_management() {
    if ! check_network_permissions; then
        echo
        read -p "按任意鍵返回主菜單..." -n1 -s
        return
    fi
    
    while true; do
        show_header
        echo -e "${BLUE}=== 網路介面管理 ===${NC}"
        echo
        show_network_menu
        read -r choice
        
        case $choice in
            1)
                show_header
                echo -e "${BLUE}=== 當前網路介面 ===${NC}"
                echo
                show_current_interfaces
                read -p "按任意鍵繼續..." -n1 -s
                ;;
            2)
                show_header
                create_dummy_interface
                echo
                read -p "按任意鍵繼續..." -n1 -s
                ;;
            3)
                show_header
                create_bridge_interface
                echo
                read -p "按任意鍵繼續..." -n1 -s
                ;;
            4)
                show_header
                create_vlan_interface
                echo
                read -p "按任意鍵繼續..." -n1 -s
                ;;
            5)
                show_header
                configure_interface_ip
                echo
                read -p "按任意鍵繼續..." -n1 -s
                ;;
            6)
                show_header
                toggle_interface
                echo
                read -p "按任意鍵繼續..." -n1 -s
                ;;
            7)
                show_header
                delete_virtual_interface
                echo
                read -p "按任意鍵繼續..." -n1 -s
                ;;
            8)
                show_header
                monitor_interface_traffic
                echo
                read -p "按任意鍵繼續..." -n1 -s
                ;;
            0)
                break
                ;;
            *)
                echo -e "${RED}無效的選項，請重新選擇${NC}"
                sleep 2
                ;;
        esac
    done
}

# 主程序
main() {
    # 啟動時檢查更新
    check_for_updates
    
    while true; do
        show_header
        show_menu
        read -r choice
        
        case $choice in
            1)
                cleanup_docker_images
                ;;
            2)
                system_status
                ;;
            3)
                network_speed_test
                ;;
            4)
                system_overview
                ;;
            5)
                network_interface_management
                ;;
            6)
                manual_update_check
                ;;
            0)
                echo -e "${GREEN}感謝使用 Ubuntu 工具箱！${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}無效的選項，請重新選擇${NC}"
                sleep 2
                ;;
        esac
    done
}

# 檢查是否為 root 用戶 (某些功能可能需要)
if [[ $EUID -eq 0 ]]; then
    echo -e "${YELLOW}注意: 您正在以 root 用戶身份運行此工具${NC}"
    echo -e "${YELLOW}某些功能可能需要普通用戶權限${NC}"
    echo
fi

# 啟動主程序
main
