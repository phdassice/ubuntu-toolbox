#!/bin/bash

# Ubuntu Toolbox - 系統管理工具集
# 作者: phdassice
# 版本: 1.0.0

set -e

# 顏色定義
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 顯示標題
show_header() {
    clear
    echo -e "${CYAN}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║                    ${YELLOW}Ubuntu 工具箱${CYAN}                          ║${NC}"
    echo -e "${CYAN}║                    ${GREEN}v1.0.0${CYAN}                                ║${NC}"
    echo -e "${CYAN}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo
}

# 顯示主菜單
show_menu() {
    echo -e "${BLUE}請選擇要執行的功能：${NC}"
    echo
    echo -e "${GREEN}1.${NC} Docker Dangling Images 清理"
    echo -e "${GREEN}2.${NC} 系統狀態查詢"
    echo -e "${GREEN}3.${NC} 網路速度測試"
    echo -e "${GREEN}4.${NC} 系統資訊總覽"
    echo -e "${RED}0.${NC} 退出工具箱"
    echo
    echo -n -e "${YELLOW}請輸入選項 [0-4]: ${NC}"
}

# 檢查 Docker 是否安裝
check_docker() {
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}錯誤: Docker 未安裝或不在 PATH 中${NC}"
        echo -e "${YELLOW}請先安裝 Docker 再使用此功能${NC}"
        return 1
    fi
    
    if ! docker info &> /dev/null; then
        echo -e "${RED}錯誤: Docker daemon 未運行或權限不足${NC}"
        echo -e "${YELLOW}請確保 Docker 服務正在運行，並且您有執行 Docker 的權限${NC}"
        return 1
    fi
    return 0
}

# Docker Dangling Images 清理
cleanup_docker_images() {
    show_header
    echo -e "${BLUE}=== Docker Dangling Images 清理 ===${NC}"
    echo
    
    if ! check_docker; then
        echo
        read -p "按任意鍵返回主菜單..." -n1 -s
        return
    fi
    
    echo -e "${YELLOW}正在檢查 dangling images...${NC}"
    
    # 獲取 dangling images
    dangling_images=$(docker images -f "dangling=true" -q)
    
    if [ -z "$dangling_images" ]; then
        echo -e "${GREEN}✓ 沒有找到 dangling images，系統已經很乾淨了！${NC}"
    else
        echo -e "${YELLOW}找到以下 dangling images:${NC}"
        docker images -f "dangling=true"
        echo
        
        read -p "確定要刪除這些 dangling images 嗎? [y/N]: " confirm
        if [[ $confirm =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}正在清理 dangling images...${NC}"
            
            # 記錄清理前的空間
            space_before=$(df -h / | awk 'NR==2 {print $4}')
            
            # 清理 dangling images
            docker rmi $(docker images -f "dangling=true" -q) 2>/dev/null || echo -e "${YELLOW}某些映像可能正在使用中${NC}"
            
            # 記錄清理後的空間
            space_after=$(df -h / | awk 'NR==2 {print $4}')
            
            echo -e "${GREEN}✓ Dangling images 清理完成！${NC}"
            echo -e "${CYAN}清理前可用空間: $space_before${NC}"
            echo -e "${CYAN}清理後可用空間: $space_after${NC}"
        else
            echo -e "${YELLOW}取消清理操作${NC}"
        fi
    fi
    
    echo
    echo -e "${BLUE}是否要執行完整的 Docker 系統清理？${NC}"
    read -p "這將清理所有未使用的容器、網路、映像和構建緩存 [y/N]: " full_cleanup
    if [[ $full_cleanup =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}正在執行完整系統清理...${NC}"
        docker system prune -a --volumes -f
        echo -e "${GREEN}✓ Docker 系統清理完成！${NC}"
    fi
    
    echo
    read -p "按任意鍵返回主菜單..." -n1 -s
}

# 系統狀態查詢
system_status() {
    show_header
    echo -e "${BLUE}=== 系統狀態查詢 ===${NC}"
    echo
    
    # 系統基本信息
    echo -e "${GREEN}📋 系統資訊:${NC}"
    echo "────────────────────────────────────────"
    echo "作業系統: $(lsb_release -d | cut -f2)"
    echo "核心版本: $(uname -r)"
    echo "主機名稱: $(hostname)"
    echo "系統運行時間: $(uptime -p)"
    echo
    
    # CPU 資訊
    echo -e "${GREEN}🖥️  CPU 資訊:${NC}"
    echo "────────────────────────────────────────"
    echo "CPU 型號: $(lscpu | grep "Model name" | cut -d: -f2 | xargs)"
    echo "CPU 核心數: $(nproc)"
    echo "CPU 使用率:"
    top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print "  使用中: " 100-$1 "% | 閒置: " $1 "%"}'
    echo
    
    # 記憶體資訊
    echo -e "${GREEN}🧠 記憶體資訊:${NC}"
    echo "────────────────────────────────────────"
    free -h | awk '
    NR==1{print "類型\t\t總計\t\t已使用\t\t可用\t\t使用率"}
    NR==2{
        total=$2; used=$3; available=$7;
        if($2~/G/) {total_gb=total} else {total_gb=total/1024}
        if($3~/G/) {used_gb=used} else {used_gb=used/1024}
        if($7~/G/) {avail_gb=available} else {avail_gb=available/1024}
        printf "記憶體\t\t%s\t\t%s\t\t%s\t\t%.1f%%\n", total, used, available, (used_gb/total_gb)*100
    }'
    echo
    
    # 磁碟使用情況
    echo -e "${GREEN}💾 磁碟使用情況:${NC}"
    echo "────────────────────────────────────────"
    df -h | grep -E '^/dev/' | awk '{
        printf "%-20s %8s %8s %8s %8s %s\n", $1, $2, $3, $4, $5, $6
    }' | head -1
    echo "────────────────────────────────────────────────────────────────────────"
    df -h | grep -E '^/dev/' | awk '{
        printf "%-20s %8s %8s %8s %8s %s\n", $1, $2, $3, $4, $5, $6
    }' | tail -n +2
    echo
    
    # 系統負載
    echo -e "${GREEN}⚡ 系統負載:${NC}"
    echo "────────────────────────────────────────"
    uptime | awk -F'load average:' '{print "平均負載:" $2}'
    echo
    
    # 網路介面
    echo -e "${GREEN}🌐 網路介面:${NC}"
    echo "────────────────────────────────────────"
    ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | while read ip; do
        interface=$(ip route get $ip | grep -oP '(?<=dev\s)\w+' | head -1)
        echo "介面: $interface | IP: $ip"
    done
    echo
    
    # 活躍的網路連接
    echo -e "${GREEN}🔗 活躍連接 (前10個):${NC}"
    echo "────────────────────────────────────────"
    netstat -tuln 2>/dev/null | head -11 || ss -tuln | head -11
    echo
    
    read -p "按任意鍵返回主菜單..." -n1 -s
}

# 檢查 speedtest-cli 是否安裝
check_speedtest() {
    if ! command -v speedtest-cli &> /dev/null; then
        echo -e "${YELLOW}speedtest-cli 未安裝，正在安裝...${NC}"
        if command -v apt &> /dev/null; then
            sudo apt update && sudo apt install -y speedtest-cli
        elif command -v yum &> /dev/null; then
            sudo yum install -y speedtest-cli
        elif command -v pip3 &> /dev/null; then
            pip3 install speedtest-cli
        else
            echo -e "${RED}無法自動安裝 speedtest-cli，請手動安裝${NC}"
            return 1
        fi
    fi
    return 0
}

# 網路速度測試
network_speed_test() {
    show_header
    echo -e "${BLUE}=== 網路速度測試 ===${NC}"
    echo
    
    if ! check_speedtest; then
        echo
        read -p "按任意鍵返回主菜單..." -n1 -s
        return
    fi
    
    echo -e "${YELLOW}正在測試網路速度，請稍候...${NC}"
    echo -e "${CYAN}這可能需要幾分鐘時間${NC}"
    echo
    
    # 顯示測試進度
    echo -e "${YELLOW}正在選擇最佳測試伺服器...${NC}"
    
    # 執行速度測試
    speedtest_result=$(speedtest-cli --simple 2>/dev/null)
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ 網路速度測試完成！${NC}"
        echo
        echo -e "${BLUE}📊 測試結果:${NC}"
        echo "════════════════════════════════════════"
        
        # 解析結果
        ping=$(echo "$speedtest_result" | grep "Ping:" | awk '{print $2 " " $3}')
        download=$(echo "$speedtest_result" | grep "Download:" | awk '{print $2 " " $3}')
        upload=$(echo "$speedtest_result" | grep "Upload:" | awk '{print $2 " " $3}')
        
        echo -e "${CYAN}延遲 (Ping):     ${YELLOW}$ping${NC}"
        echo -e "${CYAN}下載速度:        ${GREEN}$download${NC}"
        echo -e "${CYAN}上傳速度:        ${GREEN}$upload${NC}"
        echo
        
        # 速度評估
        download_mbps=$(echo "$download" | awk '{print $1}')
        if (( $(echo "$download_mbps > 100" | bc -l) )); then
            echo -e "${GREEN}🚀 網路速度很棒！${NC}"
        elif (( $(echo "$download_mbps > 50" | bc -l) )); then
            echo -e "${YELLOW}⚡ 網路速度良好${NC}"
        elif (( $(echo "$download_mbps > 25" | bc -l) )); then
            echo -e "${YELLOW}📶 網路速度普通${NC}"
        else
            echo -e "${RED}🐌 網路速度較慢${NC}"
        fi
        
        echo
        echo -e "${BLUE}是否要保存測試結果到文件？${NC}"
        read -p "[y/N]: " save_result
        if [[ $save_result =~ ^[Yy]$ ]]; then
            timestamp=$(date "+%Y-%m-%d_%H-%M-%S")
            result_file="speedtest_result_$timestamp.txt"
            {
                echo "網路速度測試結果"
                echo "測試時間: $(date)"
                echo "══════════════════════════════════════"
                echo "$speedtest_result"
            } > "$result_file"
            echo -e "${GREEN}✓ 結果已保存到: $result_file${NC}"
        fi
    else
        echo -e "${RED}✗ 網路速度測試失敗${NC}"
        echo -e "${YELLOW}請檢查網路連接後重試${NC}"
    fi
    
    echo
    read -p "按任意鍵返回主菜單..." -n1 -s
}

# 系統資訊總覽
system_overview() {
    show_header
    echo -e "${BLUE}=== 系統資訊總覽 ===${NC}"
    echo
    
    # 快速健康檢查
    echo -e "${GREEN}🏥 系統健康檢查:${NC}"
    echo "────────────────────────────────────────"
    
    # 檢查磁碟空間
    disk_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ "$disk_usage" -gt 90 ]; then
        echo -e "${RED}⚠️  磁碟空間: ${disk_usage}% (警告: 空間不足)${NC}"
    elif [ "$disk_usage" -gt 80 ]; then
        echo -e "${YELLOW}⚠️  磁碟空間: ${disk_usage}% (注意: 空間偏低)${NC}"
    else
        echo -e "${GREEN}✓ 磁碟空間: ${disk_usage}% (正常)${NC}"
    fi
    
    # 檢查記憶體使用
    mem_usage=$(free | awk 'NR==2{printf "%.0f", $3*100/$2}')
    if [ "$mem_usage" -gt 90 ]; then
        echo -e "${RED}⚠️  記憶體使用: ${mem_usage}% (警告: 使用率過高)${NC}"
    elif [ "$mem_usage" -gt 80 ]; then
        echo -e "${YELLOW}⚠️  記憶體使用: ${mem_usage}% (注意: 使用率偏高)${NC}"
    else
        echo -e "${GREEN}✓ 記憶體使用: ${mem_usage}% (正常)${NC}"
    fi
    
    # 檢查系統負載
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
    cpu_cores=$(nproc)
    load_percentage=$(echo "scale=0; $load_avg * 100 / $cpu_cores" | bc)
    
    if [ "$load_percentage" -gt 100 ]; then
        echo -e "${RED}⚠️  系統負載: ${load_avg} (警告: 負載過高)${NC}"
    elif [ "$load_percentage" -gt 80 ]; then
        echo -e "${YELLOW}⚠️  系統負載: ${load_avg} (注意: 負載偏高)${NC}"
    else
        echo -e "${GREEN}✓ 系統負載: ${load_avg} (正常)${NC}"
    fi
    
    echo
    
    # 快速統計
    echo -e "${GREEN}📈 快速統計:${NC}"
    echo "────────────────────────────────────────"
    echo "系統啟動時間: $(uptime -s)"
    echo "運行時間: $(uptime -p)"
    echo "當前用戶: $(whoami)"
    echo "登入用戶數: $(who | wc -l)"
    echo "運行進程數: $(ps aux | wc -l)"
    echo
    
    # 前5個消耗CPU的進程
    echo -e "${GREEN}🔝 CPU 使用率最高的進程 (前5個):${NC}"
    echo "────────────────────────────────────────"
    ps aux --sort=-%cpu | awk 'NR==1{print "USER\t\tPID\t%CPU\t%MEM\tCOMMAND"} NR>=2&&NR<=6{printf "%-12s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $11}'
    echo
    
    # 前5個消耗記憶體的進程
    echo -e "${GREEN}🧠 記憶體使用量最高的進程 (前5個):${NC}"
    echo "────────────────────────────────────────"
    ps aux --sort=-%mem | awk 'NR==1{print "USER\t\tPID\t%CPU\t%MEM\tCOMMAND"} NR>=2&&NR<=6{printf "%-12s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $11}'
    echo
    
    read -p "按任意鍵返回主菜單..." -n1 -s
}

# 主程序
main() {
    while true; do
        show_header
        show_menu
        read -r choice
        
        case $choice in
            1)
                cleanup_docker_images
                ;;
            2)
                system_status
                ;;
            3)
                network_speed_test
                ;;
            4)
                system_overview
                ;;
            0)
                echo -e "${GREEN}感謝使用 Ubuntu 工具箱！${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}無效的選項，請重新選擇${NC}"
                sleep 2
                ;;
        esac
    done
}

# 檢查是否為 root 用戶 (某些功能可能需要)
if [[ $EUID -eq 0 ]]; then
    echo -e "${YELLOW}注意: 您正在以 root 用戶身份運行此工具${NC}"
    echo -e "${YELLOW}某些功能可能需要普通用戶權限${NC}"
    echo
fi

# 啟動主程序
main
